Вот краткий пример подключения TestContainers для Maven и Gradle:

### Maven
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>testcontainers</artifactId>
    <version>1.19.0</version>
    <scope>test</scope>
</dependency>


Если нужна поддержка конкретной базы данных (например, PostgreSQL):
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>postgresql</artifactId>
    <version>1.19.0</version>
    <scope>test</scope>
</dependency>


### Gradle
testImplementation 'org.testcontainers:testcontainers:1.19.0'


Для конкретной базы данных (например, PostgreSQL):
testImplementation 'org.testcontainers:postgresql:1.19.0'

Вот пример использования TestContainers для поднятия базы данных (например, PostgreSQL) перед каждым тестом в проекте, предназначенном для автоматизированного тестирования:

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterEach;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import javax.sql.DataSource;
import org.apache.commons.dbcp2.BasicDataSource;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

import static org.junit.jupiter.api.Assertions.assertEquals;

@Testcontainers
public class DatabaseIntegrationTest {

    // Поднимаем PostgreSQL контейнер
    @Container
    private final PostgreSQLContainer<?> postgresContainer = new PostgreSQLContainer<>("postgres:15.1")
            .withDatabaseName("testdb")
            .withUsername("testuser")
            .withPassword("testpass");

    private DataSource dataSource;

    @BeforeEach
    void setUp() {
        // Настраиваем DataSource для подключения к тестовой БД
        BasicDataSource ds = new BasicDataSource();
        ds.setUrl(postgresContainer.getJdbcUrl());
        ds.setUsername(postgresContainer.getUsername());
        ds.setPassword(postgresContainer.getPassword());
        this.dataSource = ds;

        // Инициализация схемы и данных перед каждым тестом
        try (Connection connection = dataSource.getConnection();
             Statement stmt = connection.createStatement()) {
            stmt.execute("CREATE TABLE IF NOT EXISTS test_table (id SERIAL PRIMARY KEY, value TEXT)");
            stmt.execute("INSERT INTO test_table (value) VALUES ('test_value')");
        } catch (Exception e) {
            throw new RuntimeException("Failed to set up the database", e);
        }
    }

    @AfterEach
    void tearDown() {
        // Очистка таблиц после каждого теста
        try (Connection connection = dataSource.getConnection();
             Statement stmt = connection.createStatement()) {
            stmt.execute("DROP TABLE IF EXISTS test_table");
        } catch (Exception e) {
            throw new RuntimeException("Failed to clean up the database", e);
        }
    }

    @Test
    void testDatabaseConnection() throws Exception {
        try (Connection connection = dataSource.getConnection();
             Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT COUNT(*) FROM test_table")) {

            rs.next();
            int count = rs.getInt(1);
            assertEquals(1, count, "Table should contain exactly one row");
        }
    }
}


### Пояснение:
1. Поднимаем контейнер базы данных: Используем `PostgreSQLContainer` из TestContainers для PostgreSQL.
2. Инициализация перед тестом: В методе `@BeforeEach` создаем таблицы и наполняем их тестовыми данными.
3. Очистка после теста: В методе `@AfterEach` очищаем тестовую базу данных.
4. Тесты: В методах с аннотацией `@Test` взаимодействуем с поднятой базой, используя стандартные JDBC-функции или ORM.

### Преимущество:
Каждый тест запускается в изолированном окружении на новой базе данных, что исключает влияние состояния других тестов. Это особенно важно для надежности тестирования.

