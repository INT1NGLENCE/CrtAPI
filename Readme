
---

### Maven
1. Добавьте зависимость JPA и провайдера (например, Hibernate) в `pom.xml`:
<dependencies>
    <!-- JPA API -->
    <dependency>
        <groupId>jakarta.persistence</groupId>
        <artifactId>jakarta.persistence-api</artifactId>
        <version>3.1.0</version>
    </dependency>
    <!-- Hibernate (или другой провайдер) -->
    <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-core</artifactId>
        <version>6.3.0.Final</version>
    </dependency>
</dependencies>


2. Настройте `persistence.xml` в `src/main/resources/META-INF/`:
<persistence xmlns="..." version="2.1">
    <persistence-unit name="my-persistence-unit">
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
        <class>com.example.MyEntity</class>
        <properties>
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:mem:testdb"/>
            <property name="javax.persistence.jdbc.user" value="sa"/>
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>
        </properties>
    </persistence-unit>
</persistence>


3. В коде:
EntityManagerFactory emf = Persistence.createEntityManagerFactory("my-persistence-unit");
EntityManager em = emf.createEntityManager();


---

### Gradle
1. Добавьте зависимости в `build.gradle`:
dependencies {
    implementation 'jakarta.persistence:jakarta.persistence-api:3.1.0'
    implementation 'org.hibernate:hibernate-core:6.3.0.Final'
    runtimeOnly 'com.h2database:h2:2.2.220'
}


2. Настройте `persistence.xml` (см. пример выше).

3. Используйте `EntityManager` точно так же, как и для Maven.


Для проекта по автотестированию можно создать вспомогательный класс (утилитарный слой), который использует `EntityManager` для взаимодействия с базой данных. Этот слой можно использовать для CRUD-операций и верификаций данных в автотестах. Приведу пример вспомогательного класса `DatabaseUtility`, который будет включать несколько удобных методов для работы с базой данных.

---

### Пример вспомогательного класса
```java
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.Persistence;
import jakarta.persistence.TypedQuery;

import java.util.List;

public class DatabaseUtility {

    private static final String PERSISTENCE_UNIT_NAME = "test-persistence-unit";
    private static final EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(PERSISTENCE_UNIT_NAME);

    // Получение EntityManager
    private static EntityManager getEntityManager() {
        return entityManagerFactory.createEntityManager();
    }

    // Общий метод для выполнения операций "чтение"
    public static <T> T findById(Class<T> entityClass, Object primaryKey) {
        EntityManager em = getEntityManager();
        try {
            return em.find(entityClass, primaryKey);
        } finally {
            em.close();
        }
    }

    // Общий метод для сохранения сущности
    public static <T> void save(T entity) {
        EntityManager em = getEntityManager();
        try {
            em.getTransaction().begin();
            em.persist(entity);
            em.getTransaction().commit();
        } finally {
            em.close();
        }
    }

    // Общий метод для обновления сущности
    public static <T> void update(T entity) {
        EntityManager em = getEntityManager();
        try {
            em.getTransaction().begin();
            em.merge(entity);
            em.getTransaction().commit();
        } finally {
            em.close();
        }
    }

    // Общий метод для удаления сущности
    public static <T> void delete(Class<T> entityClass, Object primaryKey) {
        EntityManager em = getEntityManager();
        try {
            em.getTransaction().begin();
            T entity = em.find(entityClass, primaryKey);
            if (entity != null) {
                em.remove(entity);
            }
            em.getTransaction().commit();
        } finally {
            em.close();
        }
    }

    // Метод для выполнения произвольного JPQL-запроса
    public static <T> List<T> executeQuery(String jpql, Class<T> resultClass) {
        EntityManager em = getEntityManager();
        try {
            TypedQuery<T> query = em.createQuery(jpql, resultClass);
            return query.getResultList();
        } finally {
            em.close();
        }
    }

    // Метод для очистки таблицы (удобно для тестов)
    public static void clearTable(String tableName) {
        EntityManager em = getEntityManager();
        try {
            em.getTransaction().begin();
            em.createQuery("DELETE FROM " + tableName).executeUpdate();
            em.getTransaction().commit();
        } finally {
            em.close();
        }
    }

    // Graceful shutdown (вызывать в конце или в @AfterClass в ваших тестах)
    public static void shutdown() {
        if (entityManagerFactory.isOpen()) {
            entityManagerFactory.close();
        }
    }
}
```

---

### Как это использовать в автотестах

1. **Сохранение данных в базу для подготовки данных теста**:
```java
User user = new User("test_user", "test@example.com");
DatabaseUtility.save(user);
```

2. **Получение данных из базы для проверок**:
```java
User userFromDb = DatabaseUtility.findById(User.class, userId);
assert userFromDb.getEmail().equals("test@example.com");
```

3. **Очистка таблицы после теста**:
```java
DatabaseUtility.clearTable("User");
```

4. **Выполнение проверки с запросом (например, подсчет записей)**:
```java
long count = DatabaseUtility.executeQuery("SELECT COUNT(u) FROM User u", Long.class).get(0);
assert count == 0;
```

5. **Закрытие ресурсов после завершения тестового набора**:
```java
DatabaseUtility.shutdown();
```

---

Этот класс абстрагирует все взаимодействие с `EntityManager`, упрощая работу с базой в тестах. Он делает автотесты более читаемыми и легко поддерживаемыми!
